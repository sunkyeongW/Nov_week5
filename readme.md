# 1. 프로토콜(HTTP)
    컴퓨터들 간의 원활한 통신을 위해 지키기로 약속한 규약이다. 상호 간 원활한 교류, 소통, 통신을 위해 서로 동일하게 어떠한 설정/규칙을 정한다는 뜻이다.
    
    1_1. 프로토콜이 필요한 이유
        사용자 별로 환경이 다르고 통신의 규칙 없이 충돌, 지연 등 여러가지 문제가 발생할 수 있기 때문이다.

    1_2. 프로토콜 종류
        - 인터넷 표준 프로토콜(TCP/IP) : 컴퓨터 네트워크에서 인터넷 연결에 있어 핵심이면서 중요한 역할을 한다. 송신자가 수신자에게 IP주소를 사용하여 데이터를 전달(IP)하고 그 데이터의 흐름을 조절하고 성공적으로 수신자에게 전달할 수 있수 있게 보장해주는 역할(TCP)을 한다.
        - FTP (파일 전송 프로토콜)
        - SMTP(인터넷 상에서 전자 메일을 전송할 때 쓰이는 프로토콜)
        - VoIP(음성 인터넷 프로토콜)
    
    1_3. TCP/IP 4계층
        - 응용 계층(Application Layer)
            사용자와 가장 가까운 계층이며, 서버나 클라이언트 응용 프로그램들이 동작하는 곳이다.
            HTTP, Telnet, SSH, FTP, SMTP POP3, DNS 프로토콜이 존재한다.

        - 전송 계층 (Transport Layer)
            프로세스 간의 신뢰성 있는 데이터 송수신을 담당하는 계층이다.
            TCP : 신뢰성 있는(페킷에 대한 오류처리나 재전송따위로 에러를 복구하는 것) 연결지향형 프로토콜이다. 때문에 신뢰성 보장을 위해 헤더 안에는 오류 코드에 대응할 수 있는 각종 정보가 들어있다.
            UDP : 비신뢰성 비연결형 프로토콜이다. 페킷을 잃거나 오류가 있어도 대처하지 않는 것을 말한다.

        - 인터넷 계층 (Internet Layer)
            받은 데이터에 IP패킷 헤더를 붙여 IP패킷을 만들고 이를 전송 하는 것이다. 통신 노드 간의 IP패킷을 전송하는 기능 및 라우팅 기능을 담당한다.
            IP, ARP(주소 변환 프로토콜,IP주소를 물리주소로 변환하는 프로토콜), RARP(물리 주소로 IP주소를 찾는 프로토콜), ICMP(상태 진단 메시지 프로토콜), IGMP(멀티캐스트용 프로토콜)이 존재한다.

        - 네트워크 인터페이스 계층 (Network Interface Layer)
            운영체제의 네트워크 카드와 데바이스 드라이버 등 하드웨어적인 요소와 관련된 모든 것을 지원하는 계층이다.
            네트워크 접속 계측의 송신 측 컴퓨터는 상위 계층으로부터 받은 패킷에 물리 주소를 헤더에 추가하여 프레임을 만든 뒤 하위 계층인 물리 계층에 전달한다.
            수신 측 컴퓨터는 데이터 링크 계층에서 추가한 헤더 제거 후 상위 계층인 네트워크 계층에 전달한다.
            이더넷, 802.11x, MAC/LLC, SLIP, PPP 등의 프로토콜이 존재한다.



# 2. AJAS (Asynchronous Javascript And XML)
    자바스크립트와 XML을 이용하여 클라이언트와 서버가 비동기식 통신을 하는 개념이다.

    2_1. 원리
        먼저 HTML 페이지 전체를 렌더링 한 뒤, 필요한 데이터를 자바스크립트로 서버에 요청한다. 그럼 서버는 해당 요청을 받아 데이터 전송 포멧의 데이터로 응답하게 되고 그 데이터를 이용하여 전체를 갱신하지 않고도 일부만 갱신 할 수 있게(비동기식)으로 진행된다.

    2_2. 장점
        일부만 갱신 할 수 있게 되기 때문에 속도가 훨씬 빠르고 자원의 낭비가 작다.
        실시간으로 변화하는 유기적인 페이지를 만든다.
        서버의 부담이 줄어드며, 비동기 방식으로 데이터를 주고 받기 때문에 사용자의 편의성이 증가한다.

    2_3. 단점
        연속적으로 데이터를 요청하면 서버에 부하가 증가될 수 있으며, 보안이 취약하다.
        일부만 갱신하기 때문에 페이지 단위로 저장되는 히스토리가 남지 않는다. 그러기에 쿠키나 세션을 이용한다.

 # 3. 웹 통신 간 정보 유지
    쿠키 : HTPP의 일종으로 사용자가 어떠한 웹 사이트를 방문할 경우, 그 사이트가 사용하고 있는 서버에서 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일이다.
        - 특징
            이름, 값, 만료일(저장 기간 설정), 경로 정보로 구성되어있다.
            클라이언트에 총 300개의 쿠키를 저장할 수 있다.
            하나의 도메인 당 20개의 쿠키를 가질 수 있다.
    
    세션 : 일정 시간동안 같은 브라우저로부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 일정하게 유지시키는 기술이다. 즉, 방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고 그것을 세션이라고 한다.
        - 특징
            웹 서버에 웹 컨테이너 상태를 유지하기 위한 정보를 저장하고 브라우저를 닫거나, 서버에서 세션을 삭제했을 때만 삭제가 되므로, 비교적 쿠키보다 보안이 좋다.
            각 클라이언트 고유 세션ID를 부여한다. 세션ID로 클라이언트를 구분하여 각 클라이언트 요구에 맞는 서비스를 제공한다.

# 4. 포트 (Port)
    IP 내에서 애플리케이션 상호 구분(프로세스 구분)을 위해 사용하는 번호이다.
    포트 숫자는 IP 주소가 가르키는 PC에 접속할 수 있는 통로를 의미한다.
    
    0~1023번까지의 포트를 well-known port라고 한다. (ex)http : 80번 포트, ssh : 22번 포트)

    4_1. netstat 명령
        네트워크 접속, 라우팅 테이블, 네트워크 인터페이스의 통계 정보를 보여주는 도구이다.

        - 옵션
            -l (listen) : 연결 가능한 상태
            -n (number port) : 포트 넘버
            -t (tcp) : tcp
            -u (udp) : udp
            -p : 프로그램 이름 / PID
            -a : 모두
            -i : 이더넷 카드별 정상/에러/드랍 송수신 패킷 수 확인
            -r : 라우팅 테이블
            -s : 네트워크 통계

# 5. 라우팅
    인터넷네트워크를 통하여 근원지에서 목적지로 데이터가 전달될수 있도록 하는 기능이다. 많은 경로 중 하나를 선택하여 이동하는 것이다.
    
    5_1. 정적 경로 설정 vs 동적 경로 설정
        - 정적 경로 설정(Static Routing Protocol) : 관리자가 네트워크에 대한 경로 정보를 직접 지정

            장,단점
                라우팅 정보만을 참조하므로 속도가 빠르며 안정적이지만, 등록해야 할 네트워크의 수가 많을 경우에는 능동적으로 경로 설정을 변경하기 어렵다.

        - 동적 경로 설정(Dynamic Routing Protocol) : 대규모 네트워크에 사용하며 인접한 라우터 간에 동일한 라우팅 프로토콜을 설정하여 라우터 간에 변경된 네트워크에 대한 정보를 자동으로 교환한다.

            장,단점
                라우터 간에 서로 라우팅 정보를 주고 받아 라우팅 테이블을 라우터가 자동으로 작성하기 때문에 네트워크 관리자는 초기 설정만 하면된다. 하지만 라우터의 메모리를 많이 차지한다.
    
    5_2. 라우팅 프로토콜
        IGP : 네트워크의 집합을 몇 개의 그룹으로 나누었을 때 동일 그룹 내에서 라우팅 정보를 교환할 때 사용하는 라우팅 프로토콜이다.

        EGP : 다른 그룹과 라우팅 정보를 교환하는 프로토콜이다.
            시스템 사이에 경로 설정 정보 등을 교환하기 위해 사용하는 프로토콜이며 다른 도메인 사이에 라우팅 시, 정리된 관리가 거의 없고 많은 경우에 신용도가 매우 낮아 빠른 수행보다는 보안과 제어에 적합하다.


# 6. NAT (Network Adress Translation)
    사설 IP를 공인 IP로 변경에 필요한 주소 변환 서비스이다. 주로 기업이나 기관에서 내부망을 사용하는 PC에 사설 IP를 제공하고 외부 인터넷에 연결 시엔 공인 IP 하나를 같이 사용하는 형태로 운영된다.
    NAT은 다수의 주소 변환 정보에 대해 IP주소와 PORT 번호로 구성된 NAT Forwarding Table을 보관하고 있고 이에 맞게 주소 변환 서비스를 제공한다.

        NAT의 종류
            Static(정적) NAT : 주소들을 1:1 매핑으로 변환해주는 유형이다.
                가장 쉬운 변환 방법이지만, 1:1 구조이기에 효율적으로 쓰이지는 못한다.
            Dynamic(동적) NAT : 1:N 맵핑하여 변환해주는 유형이다.
                공인 IP를 효율적으로 사용하려는 목적에 부합하는 NAT 방식이다.
            
# 7. 네트워크 명령어
    ipconfig : pc의 네트워크 설정 값을 확인/변경 할 수 있다.
    ping (paket internet groper): 컴퓨터 네트워크 상태를 점검, 진단하는 명령어다. 네트워크 상태를 확인하려는 대상 컴퓨터를 향해 일정 크기의 패킷(네트워크 최소 전송단위)를 보낸후 대상 컴퓨터가 이에 대해 응답하는 메시지를 보내면 이를 수신,분석하여 컴퓨터를 파악한다. 
    nslookup : DNS 서버에 도메인이나 IO주소를 질의를 해서 DNS 서버에 있는 정보를 응답받을 때 사용하는 명령어이다. 

# 8. 허브(HUB)
    네트워크 장비와 장비를 연결해주는 기능을 수행하는 장비이다. 전기적인 신호를 증폭시켜 LAN의 전송거리를 연장시키고, 여러대의 장비를 LAN에 접속 할 수 있도록 한다.
    
    8_1. 허브 종류
        더비 허브(Dummy hub) : 컴퓨터와 컴퓨터를 연결시켜주는 일반적인 허브
            허브에 전달되는 데이터를 모든 컴퓨터로 전달하는데 이 때 허브에 연결된 다른 컴퓨터들은 통신 할 수 없고, 데이터 전송이 끝날 때까지 기다려야한다.

        스위칭 허브(Switching hub) : 데이터를 연결된 모든 컴퓨터로 전송하지 않고, 순간순간 포트를 스위칭해서 목적지에만 전달한다.
            각 포트마다 전용 할당이 가능하고 연결된 장치 수량 제한을 받지않으며 속도가 떨어지지 않고 사용이 가능한 장치이다.

        인텔리전트 허브(Intelligent hub) : NMS(Network Management System)에 따라 더미 허브와 차이점을 보여준다.
        더비 허브에서 NMS 기능이 추가된 허브로, 모든 데이터를 분석 및 제어가 가능하다.

# 9. 스위치
    허브와 비슷하게 네트워크를 분배시켜주는 역할을 한다. 내부에 메모리를 갖고 있어 각 포트에 연결되어 있는 컴퓨터들의 MAC주소들이 여기에 기록되어 있다.
    또한, 데이터의 전송 에러 등을 복구해주는 기능을 가지고 있다.

        #9_1. 허브와 스위치의 차이점
            허브의 경우 내부 연결 통로를 공유하는 방식이다. 스위치의 경우 각 포트별로 상대 포트로 향하는 독립적인 통로를 가지고 있다. 그러다 보니 허브같은 경우에는 서로 충돌이 발생하고 해당 컴퓨터는 다시 통신을 시도해야 하지만 스위치의 경우 다른 포트의 통신 유무에 상관없이 통신이 가능하다. 
        
# 10. HTTP와 HTTPS
    HTTP : 인터넷에서 하이퍼 텍스트를 교환하기 위한 통신 규약이며 TCP/IP 위에서 작동된다.(포트번호:80)
    HTTPS : HTTP에 데이터 암호화가 추가된 프로토콜이다. 443번 포트를 사용하며, 네트워크 상에서 제3자가 정보를 볼 수 없도록 암호화를 지원하고 있다.
        HTTP 대칭키 암호화와 비대칭키 암호화
            대칭키 암호화 : 클라이언트와 서버가 동일한 키를 사용해 암호화/복구화를 진행한다. 키가 노출되면 매우 위험하지만 연산 속도가 빠르다.
            비대칭키 암호화 : 1개의 쌍으로 구성된 공개키와 개인키를 암호화/복구화 하는데 사용한다. 키가 노출되어도 비교적 안전하지만 연산 속도가 느리다.

# 11. HASH

    11.1 해시
        - 임의의 크기를 가진 데이터(key)를 고정된 크기의 데이터(Value)로 변화시켜 저장하는 것이다. 키에 대한 해시값을 사용하여 값을 저장하고 키-값 쌍의 갯수에 따라 동적으로 크기가 증가한다.
        - 해시값 자체를 인덱스로 사용하기 때문에 평균 시간복잡도가 O(1)로 매우 빠르다.

    11.2 해시 함수 
        - 해시 함수는 임의의 길이를 갖는 메시지를 입력 받아 고정된 길이의 해시값을 출력하는 함수이다.
        - 입력 값의 아주 일부만 변경되어도 전혀 다른 결과 값을 출력한다.

    11.3 해시 테이블
        연관 배열구조를 이용하여 데이터를 key와 value로 저자하는 자료구조이다. 해시 테이블을 해시 함수를 사용하여 색인(index)을 버킷(bucket)이나 슬롯(slot)의 배열로 계산한다.

            연관 배열구조란?
                연관 배열은 자료구조의 하나로, 키 하나와 값 하나가 연관되어 있으며 키를 통해 연관되는 값을 얻을 수 있다.

            연관 배열이 지원하는 명령
                - 키와 값이 주어졌을 때, 연관 배열에 그 두 값을 저장하는 명령
                - 키가 주어졌을 때, 연관되는 값을 얻는 명령
                - 키와 새로운 값이 주어졌을 때, 원래 키에 연관된 값을 새로운 값으로 교체하는 명령
                -키가 주어졌을 때, 그 키에 연관된 값을 제거하는 명령

        장점
            중복을 제거할 수 있으며 데이터 캐싱, 보안에 주로 사용한다.
            배열의 인덱스로 접근하기 때문에 삽입, 삭제 등의 연산이 빠르다.

        단점
            공간 복잡도가 커지고, 충돌이 발생할 수 있다.
            순서가 있는 배열에는 어울리지 않는다.

    11.4 충돌(Collision)
        서로 다른 문자열이 해시 함수를 통하여 해싱한 해시값이 중복인 경우를 말한다. 충돌이 많아질수록 탐색의 시간 복잡도가 O(1)에서 점점 O(n)에 가까워지게 된다.

        충돌을 해결하는 방법
            체이닝(Chaining)
                - 버켓 내에 연결리스트(Linked List)를 할당하여, 버켓에 데이터를 삽입하다가 해시 충돌이 발생하면 연결리스트로 데이터들을 연결하는 방식이다.
                - 체이닝의 경우 버켓이 꽉 차더라도 연결리스트로 계속 늘려가기에, 데이터의 주소값을 바뀌지 않는다.

            - 개방 주소법(Open Addressing)
                체이닝과 달리 해시 충돌이 일어나면 다른 버켓에 데이터를 삽입한다.
                    -선형 탐색 : 해시충돌 시 다음 버켓, 혹은 몇 개를 건너뛰어 데이터를 삽입한다.
                    -제곱 탐색 : 해시충돌 시 제곱만큼 건너뛴 버켓에 데이터를 삽입한다.
                    -이중 해시 : 해시충돌 시 다른 해시함수를 한 번 더 적용한 결과를 이용한다.

# 12. URL & URI
    URI(Uniform Resource Identifier): 인터넷에 있는 자원을 나타내는 유일한 주소이다.
    URL(Uniform Resource Locator) : 네트워크 상에서 웹페이지, 이미지, 동영상 등의 파일이 위치한 정보를 나타낸다.
        - URL의 구성
            scheme: 통신방식(프로토콜)을 결정한다. 일반적인 웹 브라우저에서는 http(s)를 사용한다.
            hosts: 웹 서버의 이름, 도메인, IP를 사용하며 주소를 나타낸다.
            url-path: 웹 서버에서 지정한 루트 디렉토리부터 시작하여 웹페이지,이미지 등이 위치한 경로와 파일명을 나타낸다.

# 13. RESTful
    13.1 REST(Representational State Transfer)
        HTTP URI를 통해 자원(Resource)을 명시하고, HTTP METHOD(POST, GET,PUT,DELETE)를 통해 자원에 대한 CRUD Operation을 적용하는 것을 의미한다.

    13.2 REST의 장단점
        장점
         -HTTP 프로토콜의 인프라를 그대로 사용하므로 REST API 사용을 위한 별도의 인프라를 구출할 필요가 없다,
         -HTTP표준 프로토콜에 따르는 모든 플랫폼에서 사용이 가능하다.
         -REST API 메시지가 의도하는 바를 명확하게 나타내므로 의도하는 바를 쉽게 파악할 수 있다.

         단점
         -사용할 수 있는 메소드가 한정적이며, 브라우저를 통해 테스트 할 일이 많은 서비스라면 쉽게 고칠 수 있는 URL보다 Header 값이 왠지 더 어렵게 느껴진다.

    13.3 REST 구성 요소
        1. 자원(Resource) : URL
            모든 자원에 고유한 ID가 존재하고, 이 자원은 서버에 존재한다.
            클라이언트는 URI를 이용해서 자원을 지정하고 해당 자원의 상태(정보)에 대한 조작을 서버에 요청한다.
        2. 행위(Verb) : HTTP Method
            HTTP 프로토콜의 메소드를 사용한다.
            HTTP 프로토콜은 GET,POST,PUT,DELETE와 같은 메서드를 제공한다.
        3. 표현(Representational State Transfer)
            클라이언트가 자원의 상태(정보)에 대한 조작을 요청하면 서버는 이에 적절한 응답을 보낸다.
            REST에서 하나의 자원은 JSON,XML,TEXT 등 여러 형태의 응답으로 나타내어 질 수 있다.

    13.4 REST API
        API는 데이터와 기능의 집합을 제공하여 컴퓨터 프로그램간 상호작용을 촉진하며, 서로 정보를 교환가능 하도록 하는 것이다.

        즉, REST API는 REST 기반으로 서비스 API를 구현한 것이다.
        REST 기반으로 시스템을 분산해 확장성과 재사용성을 높여 유지보수 및 운용을 편리하게 할 수 있다.
        REST는 HTTP 표준을 기반으로 구현하므로, HTTP를 지원하는 프로그램 언어로 클라이언트, 서버를 구현할 수 있다.

    13.5 RESTful
        REST를 구현하는 웹 서비스를 나타내기 위해 사용되는 용어이다.
        REST API를 제공하는 웹서비스를 RESTful이라고 할 수 있다.



# 14. 클라우드 서비스 종류
    IaaS(Infrastructure as a Service) : 확장성이 높고 자동화된 컴퓨터 리소스를 가상화하여 제공하는 것이다.
         - 물리적 자원 제공 : 고객에게 서버, 네트워크, OS, 스토리지를 가상화하여 제공하고 관리한다.
         - IaaS는 가상화된 물리적인 자산을 UI형태의 대시보드 또는 API로 제공한다.
         - 기존의 데이터센터에서 제공받던 물리적인 자산을 완벽하게 가상화하여 제공하기 때문에 서버 사양의 변경 등 물리적 자산의 수정이 필요한 경우 기존의 방식에 비해 훨씬 빠른 대응이 가능하다.

    PaaS(Platform as a Service): 주로 응용 프로그램을 개발할 때 필요한 플랫폼을 제공하는 것이다.
        - 소프트웨어 개발을 돕는 플랫폼 제공 : PaaS는 고객에게 OS, 미들웨어, 런타임과 같은 소프트웨어 작성을 위한 플랫폼을 가상화하여 제공하고 관리한다.
        - 이 가상화된 플랫폼은 웹을 통해 제공되며 개발자는 운영체제, 소프트웨어 업데이트, 저장소 또는 인프라에 대한 관리없이 소프트웨어 개발에 집중 할 수 있다.
        - PaaS를 사용하면 기업에서는 특수 소프트웨어 구성 요소를 사용하여 PaaS에 내장된 응용 프로그램을 설계하고 만들 수 있다. 이러한 응용 프로그램 또는 미들웨어는 특정 클라우드 특성을 채택할 때 확장 가능하고 가용성이 높다.

    SaaS(Software as a Service) : 사용자에게 제공되는 소프트웨어를 가상화하여 제공하는 것이다. 타사 공급 업체가 관리하는 사용자에게 응용 프로그램을 제공하기 위해 인터넷을 사용한다. 대부분 SaaS 애플리케이션 웹 브라우저를 통해 직접 실행되므로 클라이언트 측에서 다운로드나 설치가 필요하지 않다.
        - 고객이 사용하는 소프트웨어 제공 :SaaS는 고객을 대신하여 소프트웨어와 데이터를 제공하고 관리한다.
        - 패키지 또는 On-premise 방식인 기존의 소프트웨어 전달 방식과 다르게 SaaS는 개별 컴퓨터에 응용 프로그램을 다운로드하고 설치할 필요가 없다. 

# 15. 인프라의 구성
    이중화: 하나의 기능을 병렬로 여러 개 나열해서 하나에 장애가 발생해도 다른 것을 이용해서 서비스를 계속 할 수 있는 것을 의미한다.
    하나의 기능이 병렬로 가동되기 때문에 이런 고가용성에 대한 의미뿐만 아니라 확장성이나 부하분산 같은 성능도 가지고 있다.

        구성
            1. Active-Active : 서버 두 대를 모두 운영하는 방식이다. 두 서버 모두 일을 하다가 한쪽 서버에 문제가 발생하면 나머지 한쪽이 모든 트래픽을 처리한다. 장애가 발생해도 시스템을 사용할 수 없는 시간(downtime)이 없다.

                로드 밸런싱(load balancing)

            2. Active-Standby : 서버 두 대 중 하나만 운영 서버로 활용하고, 나머지 한 대는 장애 발생 시 운영 서버를 대체해서 작동하는 방식이다. 엑티브 서버에 장애가 발생하면 수동 또는 자동으로 스탠바이 서버를 작동시켜 대응한다. 다만 스탠바이 서버가 액티브 서버를 문제없이 대체하기 위해선 평소 엑티브 서버의 데이터를 스탠바이 서버의 데이터와 동기화하는 작업이 필요하다.

                - Hot standby : Standby 측은 가동 후 즉시 이용 가능한 구성
                - Warm standby : Standby 측은 가동 후 이용 가능하게 하기 위해서 나름대로의 준비가 필요한 구성
                - Cold standby : Standby 측을 정지시켜 두는 구성

    fairover(장애 극복 기능)
        실 운용환경(컴퓨터 서버, 시스템, 네트워크) 등에서 이상이 생겼을 때 대체 작동 또는 장애 극복(조치)을 위하여 예비 운용환경으로 자동전환되는 기능이다.

 
 
 # 16. 컨테이너(Container)
    - OS상에 논리적인 구획(컨테이너)를 만들고, 어플리케이션을 작동시키기 위해 필요한 라이브러리나 어플리케이션 등을 하나로 모아, 마치 별도의 서버인 것 처럼 사용할 수 있게 만든 것이다.
    - 호스트 OS의 리소스를 논리적으로 분리시키고, 여러 개의 컨테이너가 공유하여 사용한다. 컨테이너는 오버헤드가 적기 때문에 가볍고 고속으로 작동하는 것이 특징이다.
    - 과거에 사용했던 가상 머신(VM)은 하이퍼바이저 위에 Guest OS가 올라가는데 그위에 Binary, 라이브러리 등을 모두 구성해야 하기에 무겁고 성능 저하가 발생하는데 이러한 문제를 해결한 게 컨테이너 방식이다.
    - 컨테이너는 커널을 공유한다. 그렇기에 보안이 취약할 수 밖에 없다.

    # 도커 : 컨테이너 기반의 오픈소스 가상화 플랫폼이다.
        도커를 사용하면 인프라에서 애플리케이션을 분리하여 컨테이너로 추상화시켜 소프트웨어를 빠르게 제공할 수 있다.
        
        # 도커 이미지 : 도커에서 서비스 운영에 필요한 서버 프로그램, 코드 및 라이브러리, 컴파일된 실행 파일 등을 묶는 형태를 도커 이미지라고 한다. 
        이러한 도커 이미지를 실행(run) 하면 도커 컨테이너가 된다.

        # 도커 레이어 : 여러개의 레이어를 나누어 이미지를 구성하게 된다. 이렇게 레이어 방식을 사용하면 기존의 이미지 레이어를 이용해 다양한 이미지를 새로 만들 수 있다. 
        컨테이너를 생성할 때도 레이어 방식을 이용해 기존의 이미지 레이어 위에 읽기/쓰기 레이어를 추가하므로 용량을 절약할 수 있다.
        
        #도커 허브 : 수많은 공개 이미지를 무료로 관리해준다. 호스트들은 도커 허브에서 도커 이미지를 가져와서 실행시킬 수 있으며, 용량이 매우 큰 이미지들도 도커 허브에서 관리 해주기 때문에 사용자는 부담 없이 이용 가능하다.

    # 쿠버네티스
        - 구글이 시작한 프로젝트를 기반으로 하는 쿠버네티스는 여러 컨테이너 애플리케이션을 여러 대의 호스트에 배치하고 관리하는 작업을 자동화하는 방법을 제공한다.
        - 도커를 기반으로 컨테이너를 관리하는 서비스이다.
        - 많은 컨테이너 관리에 유용하다.

            특징
                - 컨테이너들을 모니터링하며, 컨테이너 중 하나라도 죽으면 그것을 빠르게 재시작 시켜준다.
                - 웹/앱이 준비가 되지 않았을 경우 유저가 접속해도 해당 웹사이트의 니즈를 수용할 수 있도록 자동으로 새로운 컨테이너들을 만들 수 있다.
                - 점진적 업데이트를 제공하기 때문에, 서비스를 중단하지 않고도 애플리케이션을 업데이트 할 수 있다.
                - 도커 컨테이너를 기반으로 하는 오픈소스이기 때문에, 사용자들이 특정 업체에 종속되지 않고 클라우드의 환경들을 이전할 수 있다.

# 17. XML(EXtensible Markup Language)
    HTML과 매우 비슷한 문자 기반의 마크업 언어이다. 그러나 XML은 HTML처럼 데이터를 보여주려는 목적이 아닌, 데이터를 저장하고 전달할 목적으로만 만들어졌다. 또한, XML 태그는 HTML 태그처럼 미리 정의되어 있지 않고, 사용자가 직접 정의할 수 있다.

# 18. 자바 스크립트

# jQuery    
    jQuery는 여러줄의 javascript 코드를 한줄의 코드로 호출할 수 있는 메소드로 래핑하는 기능을 가지고 있다. AJAX와 DOM 조작을 단순화 시킨다.

        특징
            - HTML/DOM 조작
            - HTML 이벤트 메서드를 쉽게 사용
            - CSS 조작 가능
            - 이펙트나 애니메이션 주기 편함

# React
    사용자 인터페이스를 만들기 위한 JavaScript 라이브러리다.
    크고 복잡한 동적인 single pase application을 만들 수 있게 됐다.

        특징
            - UI의 특정 부분을 만들어서 재사용
            - JSX를 사용하면 DOM을 직접 조작 할 수 있음
            - Virtual DOM을 제공하여 웹사이트의 성능을 높임
        
        Virtual DOM
            Virtual DOM은 하나의 가상 레이어이다. Virtual DOM에 적용하는 변경사항은 DOM에 바로 반영되지 않지만, 그 변경사항들을 모아뒀다가 한번에 DOM에 전달한다.
            
            Diffing : 첫번째 가상돔과 업데이트 이후에 발생할 두번째 가상돔을 비교해 정확히 어떤 Element가 변한지 비교해주는 표현
            - 렌더링 이전 화면 구조를 나타내는 가상돔
            - 렌더링 이후에 보이게 될 하면 구조를 나타내는 가상돔

                React는 환경이 변경될 때마다 Re-Rendering이 발생한다. 이 시점마다 새로운 내용이 담긴 가상돔을 생성하게 된다.

            diffing을 통해 차이가 발생한 부분만을 실제 DOM에 적용해준다. 이 과정을 Reconciliation(재조정)이라고 한다.

# Node.js
    Chrome V8 Javascript 엔진으로 빌드된 Javascript 런타임(프로그래밍 언어가 구동되는 환경)이다.
    빠른 웹 애플리케이션 개발이 가능하기 때문에 유지 보수 비용 절감 즉, 개발 생산성이 향상된다.

    콜백 함수
        비동기 방식으로 코드를 만드는데 시간이 걸릴 수 있기 때문에 그 다음 코드를 바로 실행한다. 그리고 나서 실행이 끝났을 때 피라미터로 전달한 함수가 실행 될 수 있다면 그 시점에 결과를 처리할 수 있으므로 효율적인 프로그램을 만들 수 있다. 이 피라미터로 전달되는 함수를 콜백함수라고 한다.

    - Node.js는 REPL(Read, Eval, Print, Loop)을 통해서 런타임을 제공한다.
        1. Read : 유저의 입력 값을 받아서 메모리에 저장
        2. Eval : 입력 값의 평가, 실행
        3. Print : Eval로 인해 반환된 값을 출력
        4. Loop : 1~3을 반복
    - Node.js는 이벤트 기반, 논 블로킹 I/O 모델을 사용해 가볍고 효율적이다. Node.js의 패키지 생태계인 npm은 세계에서 가장 큰 오픈 소스 라이브러리이다.

    - Express.js : Node.js에서 웹 애플리케이션 혹은 API 서버를 구축하는데 가장 많이 사용되는 대표적인 프레임워크이다.

        Express는 프레임워크이므로 웹 애플리케이션을 만들기 위한 각종 라이브러리와 미들웨어 등이 내장돼 있어 개발하기 편하고, 개발 규칙을 강제하여 코드 및 구조의 통일성을 향상 시킬 수 있다.

# 19. 정렬(sort)
    19_1. 오름차순 정렬
        sorted() : 내장함수, 새로운 정렬된 목록을 반환하며, 원래 목록은 영향을 받지 않는다.
        sort() : 리스트의 메소드, 리스트에서만 사용이 가능하다.

        내림차순 정렬
        reverse = True : 역순으로 정렬

    19_2 . 문자열로 이루어진 리스트
        정렬 순서는 사전 순서(알파벳 순서)를 따른다.(문자열의 길이가 긴것이 더 큰것이 아니다)

        문자열 길이 순서로 정렬하려면?
            정렬에 이용하는 키(key)를 지정
            sorted(L, key=lambda x:len(x))

        키를 지정하는 또 다른 예
            L.sort(key=lambda x:x['name'])
                -> 레코드들을 이름 순서대로 정렬
            
            L.sort(key=lambda x:x['score'],reverse=True)
                -> 레코드들을 큰 점수 순서대로 정렬

# 20. 탐색(Search)
    선형 탐색(Linear Search) : 리스트의 처음부터 끝까지 순서대로 하나씩 탐색을 진행하는 알고리즘이다.
        리스트의 길이에 비례하는 시간 소요 -> O(n)

    이진 탐색(Binary Search) : 정렬된 리스트에서 중간값이랑 비교해보고 반씩 제외하면서 찾는 알고리즘이다.
        탐색하려는 리스트가 이미 정렬되어 있는 경우에만 적용 가능
        한 번 비교가 일어날 때 마다 리스트 반씩 줄임(divide & conquer) -> O(log n)
























